{"name":"Plank","tagline":"A lightweight logger written in Swift.","body":"Plank\r\n=====\r\n\r\nWhat is Plank?\r\n--------------\r\nPlank is a lightweight logging framework for the Swift programming language that allows gating of log messages as a function of build configuration.  Plank provides a hook to filter logs based on level.\r\n```swift\r\nlet logger = Plank.Logger(tag: \"Tag\")\r\n\r\nlogger.thresholdLevel = .Warning\r\n\r\nlogger.logWarning(\"This log should appear because it is at the minimum threshold.\")\r\nlogger.logInfo(\"This log shouldn't appear because it is set below minimum threshold.\")\r\n```\r\n\r\nSet the desired threshold log level, by default it is set to .Warn.  With this example all logs will be recorded.\r\n```swift\r\nlogger.thresholdLevel = .Warning\r\n```\r\n\r\nTurn off all logs by setting the enabled property to false:\r\n```swift\r\nlogger.enabled = false\r\n```\r\n\r\nAll loggers are asynchronous by default, but one can change to synchronous by setting this aptly named property:\r\n```swift\r\nlogger.synchronous = true\r\n```\r\n\r\nOne can execute code after asynchronous logs by attaching a trailing closure.\r\n```swift\r\nlogger.logError(message) {\r\n    // Do something on logging queue immediately after log is written.\r\n}\r\n```\r\n**Note:** All logs are written on a serial queue.\r\n\r\nFor the given log statement:\r\n```swift\r\nlet logger = Plank.Logger(tag: \"JSON\")\r\nlogger.logError(\"{\\\"foo\\\":\\\"bar\\\"}\")\r\n```\r\nthe console output will look something like this:\r\n```\r\n2014-14-09 18:54:11:424 (GMT) [Test|Plank] [JSON|Error] [ViewController.swift viewDidLoad():18]\r\n{\"foo\":\"bar\"}\r\n```\r\n\r\nYou can change the format of log output by setting the formatter property, *e.g.*:\r\n```swift\r\nlogger.formatter = { (message: String, tag: String, levelString: String, function: String, file: String, line: Int) in\r\n    return \"[\\(tag)|\\(levelString)]\\n\\(message)\"\r\n}\r\nlogger.logError(message)\r\n```\r\n\r\nOptionally, one can pass a delegate to the logger in its constructor.  The delegate can be used to monitor logging activity.  This is useful for keeping a buffer of recently logged messages or writing to a file when necessary.\r\n```swift\r\npublic protocol LoggerDelegate {\r\n    func logger(logger: Logger, didLog message: String, body: String)\r\n}\r\n\r\nvar loggerDelegate: LoggerDelegate?\r\nloggerDelegate = ...\r\nlet logger = Logger(tag: tag, delegate: loggerDelegate!)\r\n\r\n```\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}